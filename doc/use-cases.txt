These are some of the ways that one can use boomerang.  This will help us make sure the library
actually supports all possible use cases.

1. Measure a page's perceived performance.

We need the ability to measure the time the user thinks it took to load a page.  This is typically
the time between the user clicking a link (or entering a URL into the browser) and the page becoming
usable.

While it's easy enough to note the time when a user clicked a link if the link was on a page you
control, it's not easy to tell the exact moment when a user enters a URL into a browser and hits
enter.  We'll therefore only concentrate on link clicks on pages that we control.

One unknown is the time when a page becomes usable.  For most pages, this is when the onload event
fires, however, there may be pages on which the onload event fires before the page is actually
usable (eg, a lot of content loaded via javascript), or when the page becomes usable before the
onload event fires (eg, hidden resources downloaded via javascript at the bottom of the page).
In both these cases, the developer of the page has a better idea of when their page has become
usable, so they should have the ability to tell the library when to fire this event.

Breaking this into four separate use cases:

1a. User clicks a link on a page we control and page is usable when onload fires
1b. User clicks a link on a page we control and page is usable at some developer determined point
1c. User types in URL/clicks a bookmark or link on a page we don't control and our page is usable when onload fires
1d. User types in URL/clicks a bookmark or link on a page we don't control and our page is usable at some developer determined point


2. Measure perceived performance of content loaded dynamically

Many websites might load contentdynamically.  For example, images for a slide show or content for
tabs may be loaded via javascript.  A stock ticker may periodically refresh itself from a back end
web service using XHR, a webmail service may check with the server for new messages or download the
selected message using javascript, etc.

In all these cases the browser may not fire an event for when the download was initiated or completed
and the library will need to expose methods/events that the web developer can invoke when needed.


3. Measure a user's bandwidth along with page load time

Since users browse the web using different types of internet connections, it's not always possible
to aggregate page load times for multiple users to get an indication of a number that's
statistically representative for all users.  Knowing the user's bandwidth, however, allows us
to aggregate data from similar users and use these numbers as representative for users with that
type of network connection.


4. Measure more than just page load time.

Many sites may be composed of separate components loaded from different back end services.  For
example, on my home page, I have widgets from dopplr, upcoming, twitter, delicious and flickr.
Now while it's important to have the overall page load time, which is what users perceive as my
page's performance, it can also be useful and instructive to measure the load time of each component
separately, but as part of the measurement for the entire page.  This allows us to then cut up
a page's load time into the load time for each of its components, and carry out statistical
analysis of each component in the context of its containing page.

To do this, the library needs to expose additional timers that the page developer can set.  These
timers should be beaconed back along with the overall page load time.


5. Measure DNS performance


